using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CodeRefactorings;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.Extensions.Logging;

namespace Rocket.Surgery.Extensions.Testing.SourceGenerators;

/// <summary>
///     The overall results of the given generator test context.
/// </summary>
/// <param name="ContextId">The unique id of the generating context</param>
/// <param name="ProjectInformation">The Test project information</param>
/// <param name="InputCompilation">The initial compilation before any generators run</param>
/// <param name="InputDiagnostics">The initial diagnostics before any generators run</param>
/// <param name="InputSyntaxTrees">The input sources that are used by the compilation and the generators</param>
/// <param name="InputAdditionalTexts">The additional input texts that are used by the generators</param>
/// <param name="Customizers">The additional customizers to handle off to verify</param>
/// <param name="Severity">The diagnostic severity to report on, can be null</param>
/// <param name="ParseOptions">The parse options that are used to determine the C# language being used</param>
/// <param name="GlobalOptions">The global options provided with the initial input</param>
/// <param name="FileOptions">The file based options provided with the initial input</param>
/// <param name="Results">The results foreach generator that was run</param>
/// <param name="AnalyzerResults">The results foreach analyzer that was run</param>
/// <param name="CodeFixResults">The results foreach codefix that was run</param>
/// <param name="CodeRefactoringResults">The results foreach refactoring that was run</param>
/// <param name="MarkedLocations">The marked locations in the source</param>
/// <param name="MetadataReference">The resolved metadata reference</param>
/// <param name="FinalCompilation">The resulting compilation with all the generators being run</param>
/// <param name="FinalDiagnostics">The resulting diagnostics with all the generators being run</param>
/// <param name="Assembly">The assembly that was generated by the resulting compilation</param>
[PublicAPI]
public record GeneratorTestResults
(
    string ContextId,
    TestProjectInformation ProjectInformation,
    CSharpCompilation InputCompilation,
    ImmutableArray<Diagnostic> InputDiagnostics,
    ImmutableArray<SyntaxTree> InputSyntaxTrees,
    ImmutableArray<AdditionalText> InputAdditionalTexts,
    ImmutableArray<GeneratorTestResultsCustomizer> Customizers,
    DiagnosticSeverity? Severity,
    CSharpParseOptions ParseOptions,
    ImmutableDictionary<string, string> GlobalOptions,
    ImmutableDictionary<string, ImmutableDictionary<string, string>> FileOptions,
    ImmutableDictionary<Type, GeneratorTestResult> Results,
    ImmutableDictionary<Type, AnalyzerTestResult> AnalyzerResults,
    ImmutableDictionary<Type, CodeFixTestResult> CodeFixResults,
    ImmutableDictionary<Type, CodeRefactoringTestResult> CodeRefactoringResults,
    ImmutableDictionary<string, MarkedLocation> MarkedLocations,
    CSharpCompilation FinalCompilation,
    ImmutableArray<Diagnostic> FinalDiagnostics,
    Assembly? Assembly,
    MetadataReference? MetadataReference
)
{
    /// <summary>
    ///     Implicitly convert the results to the final compilation
    /// </summary>
    /// <param name="results"></param>
    /// <returns></returns>
    public static implicit operator CSharpCompilation(GeneratorTestResults results)
    {
        return results.FinalCompilation;
    }

    /// <summary>
    ///     Implicitly convert the results to assembly from the final compilation
    /// </summary>
    /// <param name="results"></param>
    /// <returns></returns>
    public static implicit operator Assembly?(GeneratorTestResults results)
    {
        return results.Assembly;
    }

    /// <summary>
    ///     Implicitly convert the results to assembly from the final compilation
    /// </summary>
    /// <param name="results"></param>
    /// <returns></returns>
    public static implicit operator MetadataReference?(GeneratorTestResults results)
    {
        return results.MetadataReference;
    }

    /// <summary>
    ///     Try to get the result for the specified generator
    /// </summary>
    /// <param name="type"></param>
    /// <param name="result"></param>
    /// <returns></returns>
    public bool TryGetResult(Type type, [NotNullWhen(true)] out GeneratorTestResult? result)
    {
        return Results.TryGetValue(type, out result);
    }

    /// <summary>
    ///     Try to get the result for the specified generator
    /// </summary>
    /// <param name="result"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public bool TryGetResult<T>([NotNullWhen(true)] out GeneratorTestResult? result)
        where T : new()
    {
        return Results.TryGetValue(typeof(T), out result);
    }

    /// <summary>
    ///     Try to get the result for the specified analyzer
    /// </summary>
    /// <param name="type"></param>
    /// <param name="result"></param>
    /// <returns></returns>
    public bool TryGetAnalyzerResult(Type type, [NotNullWhen(true)] out AnalyzerTestResult? result)
    {
        return AnalyzerResults.TryGetValue(type, out result);
    }

    /// <summary>
    ///     Try to get the result for the specified analyzer
    /// </summary>
    /// <param name="result"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public bool TryGetAnalyzerResult<T>([NotNullWhen(true)] out AnalyzerTestResult? result)
        where T : new()
    {
        return AnalyzerResults.TryGetValue(typeof(T), out result);
    }

    /// <summary>
    ///     Ensure the resulting diagnostics are less than the specified severity
    /// </summary>
    /// <param name="severity"></param>
    /// <exception cref="InvalidOperationException"></exception>
    public void EnsureDiagnosticSeverity(DiagnosticSeverity severity = DiagnosticSeverity.Warning)
    {
        if (FinalDiagnostics.Any(x => x.Severity >= severity)) throw new InvalidOperationException("Compilation failed");

        foreach (var result in Results.Values)
        {
            result.EnsureDiagnosticSeverity(severity);
        }
    }

    /// <summary>
    ///     Assert that the compilation was a success
    /// </summary>
    /// <exception cref="InvalidOperationException"></exception>
    public void AssertCompilationWasSuccessful()
    {
        if (FinalDiagnostics.Any(x => x.Severity >= DiagnosticSeverity.Warning)) throw new InvalidOperationException("Compilation failed");

        foreach (var result in Results.Values)
        {
            result.EnsureDiagnosticSeverity();
        }
    }

    /// <summary>
    ///     Assert that the generation was a success
    /// </summary>
    /// <exception cref="InvalidOperationException"></exception>
    public void AssertGenerationWasSuccessful()
    {
        foreach (var item in Results.Values)
        {
            if (item.Compilation is null) throw new InvalidOperationException("Compilation must not be null");

            item.EnsureDiagnosticSeverity();
        }
    }
}

/// <summary>
///     Test project information
/// </summary>
/// <param name="Logger"></param>
/// <param name="SourceProject"></param>
/// <param name="Analyzers"></param>
/// <param name="SourceGenerators"></param>
/// <param name="IncrementalGenerators"></param>
/// <param name="CodeFixProviders"></param>
/// <param name="CodeRefactoringProviders"></param>
public record TestProjectInformation
(
    ILogger Logger,
    Project SourceProject,
    ImmutableDictionary<Type, DiagnosticAnalyzer> Analyzers,
    ImmutableDictionary<Type, ISourceGenerator> SourceGenerators,
    ImmutableDictionary<Type, IIncrementalGenerator> IncrementalGenerators,
    ImmutableDictionary<Type, CodeFixProvider> CodeFixProviders,
    ImmutableDictionary<Type, CodeRefactoringProvider> CodeRefactoringProviders
);
